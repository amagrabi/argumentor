<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArguMentor - Sharpen Your Reasoning</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <style>
    /* When selected, the category items now use gray-800 (a tiny bit darker) */
    .category-item.selected {
      background-color: #1F2937; /* Tailwind gray-800 */
      color: #fff;
      border-color: #1F2937;
    }
    .category-item {
      background-color: #fff;
      color: #000;
    }
    /* Animate the progress bar fill */
    .progress-fill {
      transition: width 0.4s ease-out, background-color 0.4s ease-out;
    }
    /* Fade-in effect for evaluation results */
    .fade-in {
      animation: fadeInAnimation 0.5s ease-in-out;
    }
    @keyframes fadeInAnimation {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .profile-icon {
      filter: grayscale(100%);
    }
    #answerInput:focus {
      border-color: #4B5563; /* Dark gray */
      outline: none;
      box-shadow: 0 0 0 2px rgba(75, 85, 99, 0.5);
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div class="max-w-5xl mx-auto px-4 py-6">
    <!-- Header -->
    <header class="flex justify-between items-center mb-4">
    <div class="flex items-center space-x-3">
        <img width="40" height="40" src="https://img.icons8.com/external-outline-berkahicon/64/external-Brain-health-app-outline-berkahicon.png" alt="Brain Health Icon">
        <h1 class="text-2xl font-bold">ArguMentor</h1>
    </div>
    <div class="flex items-center space-x-2 text-sm">
        <a href="/profile" class="flex items-center">
        <div class="flex flex-col items-end mr-2">
            <span id="userLevel" class="text-xs text-gray-500">{{ level_info.display_name }}</span>
            <div id="miniXpBar" class="w-20 h-1 bg-gray-200 rounded-full mt-1">
            <div class="h-full bg-green-500 rounded-full" style="width: {{ level_info.progress_percent }}%;"></div>
            </div>
        </div>
        <img class="profile-icon" width="32" height="32" src="https://img.icons8.com/fluency-systems-filled/48/user.png" alt="Profile Icon">
        </a>
        <button id="settingsButton" class="bg-gray-100 hover:bg-gray-200 text-gray-700 p-2 rounded-full flex items-center justify-center">
        <!-- SVG for settings icon -->
        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
        </svg>
        </button>
    </div>
    </header>

    <!-- Category Selection Modal Overlay -->
    <div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div id="settingsPanel" class="bg-white border border-gray-200 rounded-xl shadow-lg p-4 w-11/12 max-w-md">
        <h3 class="text-lg font-bold mb-2">Settings</h3>
        <hr class="border-t border-gray-200 my-2" />
        <div class="mb-4">
          <h4 class="font-bold text-md mb-3">Filter Categories</h4>
          <div class="flex gap-2 flex-wrap">
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Philosophy">Philosophy</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Ethics">Ethics</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Business & Risk">Business & Risk</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Thought Experiments">Thought Experiments</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Politics">Politics</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Biases & Fallacies">Biases & Fallacies</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Fun & Casual">Fun & Casual</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="AI & Future">AI & Future</div>
          </div>
        </div>
        <div id="categoriesError" class="text-red-500 mt-2 text-xs hidden">At least one category must be selected.</div>
        <div class="mt-4 text-right">
          <button id="closeCategories" class="bg-gray-800 text-white px-3 py-1 rounded-full text-sm hover:bg-gray-700 transition-colors">
            Done
          </button>
        </div>
      </div>
    </div>

    <!-- Slogan -->
    <p class="text-gray-600 text-center mb-8">
      Sharpen your reasoning skills. Tackle new questions, craft arguments, improve with AI-powered feedback.
    </p>

    <!-- Main Content -->
    <main class="bg-white rounded-3xl shadow-sm p-8 mb-8">
      <!-- Question Section -->
      <!-- Category badge above the question -->
      <div class="mb-2">
        <span id="categoryBadge" class="bg-gray-800 text-white px-4 py-2 rounded-full text-sm"></span>
      </div>
      <div class="flex items-start">
        <h2 id="questionDescription" class="text-3xl font-bold flex-1"></h2>
        <div class="flex flex-col ml-6 items-end">
          <!-- Reroll Button -->
          <button id="rerollButton" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 text-sm rounded-full font-medium flex items-center space-x-1">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Reroll</span>
          </button>
          <!-- Select Question Button placed below the Reroll button -->
          <button id="selectQuestionButton" class="mt-2 bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 text-sm rounded-full font-medium flex items-center space-x-1">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Select Question</span>
          </button>
        </div>
      </div>
      
      <!-- Answer Section -->
      <div class="space-y-6">
        <div class="mt-8">
          <label class="block text-lg font-bold mb-2">Your Answer</label>
          <textarea 
            id="answerInput"
            class="w-full p-4 border-2 border-gray-200 rounded-xl focus:border-gray-700 focus:ring focus:ring-gray-500 h-32"
            placeholder="Type your answer here..."
            maxlength="200"
          ></textarea>
          <div class="mt-2">
            <div class="flex justify-between text-sm text-gray-500">
              <span>Characters remaining: <span id="charCount">200</span></span>
              <button id="submitAnswer" class="bg-gray-800 text-white px-6 py-2 rounded-full hover:bg-gray-700 transition-colors">
                Submit Answer
              </button>
            </div>
            <div id="errorMessage" class="text-sm text-red-500 mt-1"></div>
          </div>
        </div>
      </div>
    </main>
    
    <!-- Evaluation Results -->
    <div id="evaluationResults" class="hidden bg-white rounded-3xl shadow-sm p-8">
    <h2 class="text-2xl font-bold mb-6">Evaluation</h2>
    <div id="scores" class="grid gap-4 mb-8">
        <!-- Dynamically populated scores and feedback -->
    </div>
    <!-- XP and Level Info Section -->
    <div id="xpInfo" class="mt-4 text-center">
        <p id="levelUpMessage" class="text-green-600 font-bold"></p>
        <p>Experience Points Gained: <span id="xpGained"><strong>0</strong></span></p>
        <p>Current Level: <span id="currentLevel"><strong>Level 1 (Novice Thinker)</strong></span></p>
        <div id="xpBarContainer" class="w-full bg-gray-200 relative rounded-full h-4 mx-auto max-w-md mt-2">
        <!-- Old XP portion (base progress) in neutral gray -->
        <div id="xpOldBar" class="absolute left-0 h-full bg-gray-500 rounded-l-full" style="width: 0%;"></div>
        <!-- New XP portion overlay in green -->
        <div id="xpNewBar" class="absolute h-full bg-green-500 rounded-r-full" style="width: 0%; left: 0%;"></div>
        </div>
        <p class="text-sm mt-1">
        Progress: <span id="xpProgressText">0 / 0</span> XP
        </p>
        <p class="text-sm mt-1">
        Next Level: <span id="nextLevel">Level 2 (Inquisitive Mind)</span>
        </p>
    </div>
    <div class="mt-6 text-center">
        <button id="nextQuestion" class="bg-gray-800 text-white px-6 py-2 rounded-full hover:bg-gray-700 transition-colors">
        Next Question
        </button>
    </div>
    </div>
  
  <div id="questionSelectionOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white border border-gray-200 rounded-xl shadow-lg p-4 w-11/12 max-w-2xl">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold">Select a Question</h3>
        <button id="closeQuestionSelection" class="bg-red-500 text-white px-3 py-1 rounded-full text-sm">X</button>
      </div>
      <div id="questionList" class="max-h-96 overflow-y-auto">
        <!-- List of questions will be dynamically populated here -->
      </div>
    </div>
  </div>
  
  <script>
    // Category icons mapping with updated icons
    const categoryIcons = {
      "Philosophy": "📚",
      "Ethics": "⚖️",
      "Business & Risk": "💼",
      "Thought Experiments": "💡",
      "Politics": "🏛️",
      "Biases & Fallacies": "🔍",
      "AI & Future": "🤖",
      "Fun & Casual": "🍻"
    };

    // Global variable that stores your selected category values.
    var selectedCategories = [];
    // Global variable to store the currently displayed question.
    var currentQuestion = null;

    // Utility functions for color interpolation
    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      let bigint = parseInt(hex, 16);
      let r = (bigint >> 16) & 255;
      let g = (bigint >> 8) & 255;
      let b = bigint & 255;
      return { r, g, b };
    }

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    function interpolateColor(color1, color2, factor) {
      const r = Math.round(color1.r + factor * (color2.r - color1.r));
      const g = Math.round(color1.g + factor * (color2.g - color1.g));
      const b = Math.round(color1.b + factor * (color2.b - color1.b));
      return { r, g, b };
    }

    // Function to determine color based on score using linear interpolation
    // Gradient from red (#e53e3e) for a low score to green (#38a169) for a high score.
    function scoreToColor(score) {
        const minScore = 1, maxScore = 10;
        const clampedScore = Math.min(maxScore, Math.max(minScore, score));
        const factor = (clampedScore - minScore) / (maxScore - minScore);
        
        // Five-color gradient: red -> orange -> yellow -> lime -> emerald
        const colors = [
            hexToRgb("#ef4444"),  // red-500 (1-3)
            hexToRgb("#f59e0b"),  // amber-500 (4-5)
            hexToRgb("#eab308"),  // yellow-500 (6)
            hexToRgb("#84cc16"),  // lime-500 (7)
            hexToRgb("#16a34a"),  // green-600 (8-9)
            hexToRgb("#059669")   // emerald-600 (10)
        ];
        
        // Split into distinct bands
        if (factor < 0.3) {
            return interpolate(colors[0], colors[1], factor / 0.3);
        } else if (factor < 0.5) {
            return interpolate(colors[1], colors[2], (factor - 0.3) / 0.2);
        } else if (factor < 0.7) {
            return interpolate(colors[2], colors[3], (factor - 0.5) / 0.2);
        } else if (factor < 0.9) {
            return interpolate(colors[3], colors[4], (factor - 0.7) / 0.2);
        } else {
            return interpolate(colors[4], colors[5], (factor - 0.9) / 0.1);
        }
        
        function interpolate(start, end, ratio) {
            const result = {
                r: Math.round(start.r + (end.r - start.r) * ratio),
                g: Math.round(start.g + (end.g - start.g) * ratio),
                b: Math.round(start.b + (end.b - start.b) * ratio)
            };
            return rgbToHex(result.r, result.g, result.b);
        }
    }

    window.addEventListener('load', () => {
        fetch('/get_question')
            .then(response => response.json())
            .then(question => {
            if (question.error) {
                console.error('Error fetching question:', question.error);
                return;
            }
            document.getElementById('questionDescription').textContent = question.description;
            // Update the category badge as well, if needed.
            const categoryText = question.category ? question.category : '';
            document.getElementById('categoryBadge').textContent = categoryText;
            })
            .catch(err => console.error('Error fetching initial question:', err));
        });

    async function getNewQuestion() {
        try {
            const response = await fetch('/get_new_question');
            const question = await response.json();
            if (question.error) {
            console.error('Error fetching new question:', question.error);
            return;
            }
            
            // Update the question description:
            const questionElem = document.getElementById('questionDescription');
            if (questionElem) {
            questionElem.textContent = question.description;
            }
            
            // Update the category badge:
            const categoryBadge = document.getElementById('categoryBadge');
            if (categoryBadge) {
            categoryBadge.textContent = question.category || '';
            }
            
            // Automatically scroll up to the new question
            questionElem.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
        } catch (error) {
            console.error('Error in getNewQuestion:', error);
        }
    }

    // Make sure the Next Question button triggers the above function:
    document.getElementById('nextQuestion').addEventListener('click', getNewQuestion);

    // Character counter and clear error messages on input
    const answerInput = document.getElementById('answerInput');
    const charCount = document.getElementById('charCount');
    answerInput.addEventListener('input', () => {
      const remaining = 200 - answerInput.value.length;
      charCount.textContent = remaining;
      document.getElementById('errorMessage').textContent = '';
    });

    // Helper function for number animation
    function animateNumber(element, start, end, interval) {
      let current = start;
      const steps = 15;
      const stepValue = (end - start) / steps;
      const startColor = hexToRgb("#e53e3e");
      const endColor = hexToRgb(element.getAttribute('data-color'));
      
      const timer = setInterval(() => {
        current += stepValue;
        const factor = (current - start) / (end - start);
        const color = interpolateColor(startColor, endColor, factor);
        element.style.color = rgbToHex(color.r, color.g, color.b);
        
        if ((stepValue > 0 && current >= end) || (stepValue < 0 && current <= end)) {
          current = end;
          clearInterval(timer);
        }
        element.textContent = Math.floor(current) + '/10';
      }, 30);
    }

    // Helper function for typewriter effect
    function typeWriter(element, text, speed) {
      element.textContent = ''; // clear existing text
      let i = 0;
      const timer = setInterval(() => {
        element.textContent += text.charAt(i);
        i++;
        if (i >= text.length) {
          clearInterval(timer);
        }
      }, speed);
    }

    // Submit answer and display evaluation with scores and feedback
    document.getElementById('submitAnswer').addEventListener('click', async () => {
      const answer = answerInput.value.trim();
      if (!answer) {
        document.getElementById('errorMessage').textContent = "Please provide an answer before submitting.";
        return;
      }
      try {
        const response = await fetch('/submit_answer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ answer })
        });
        
        const data = await response.json();

        const scoresDiv = document.getElementById('scores');
        scoresDiv.innerHTML = '';
        Object.entries(data.evaluation.scores).forEach(([category, score]) => {
          const finalScore = score;             // e.g. 6, 7, 8 or 9
          const finalWidthPercent = score * 10;   // e.g. 60%, 70%, etc.
          const color = scoreToColor(score);
          const feedbackText = data.evaluation.feedback[category] || '';
          scoresDiv.innerHTML += `
            <div class="mb-4">
              <div class="flex justify-between items-center">
                <span class="font-medium">${category}</span>
                <span class="font-medium score-value" data-final="${finalScore}" data-color="${color}" style="color: #e53e3e;">1/10</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-2 mt-1">
                <div class="rounded-full h-2 progress-fill" 
                      data-score="${finalWidthPercent}" 
                      data-color="${color}"
                      style="width: 10%; background-color: #e53e3e;"></div>
              </div>
              <p class="text-sm text-gray-500 feedback" data-final="${feedbackText}"></p>
            </div>
          `;
        });
        
        setTimeout(() => {
          document.querySelectorAll('.progress-fill').forEach((fill, index) => {
            const delay = index * 100;
            setTimeout(() => {
              const targetWidth = fill.getAttribute('data-score');
              const targetColor = fill.getAttribute('data-color');
              fill.style.backgroundColor = '#e53e3e';
              fill.style.width = '10%';
              void fill.offsetWidth;
              fill.style.width = targetWidth + '%';
              fill.style.backgroundColor = targetColor;
            }, delay);
          });
          document.querySelectorAll('.score-value').forEach((span, index) => {
            const delay = index * 100;
            setTimeout(() => {
              animateNumber(span, 1, parseInt(span.getAttribute('data-final')), 30);
            }, delay);
          });
          document.querySelectorAll('.feedback').forEach((paragraph, index) => {
            const delay = index * 100;
            setTimeout(() => {
              typeWriter(paragraph, paragraph.getAttribute('data-final'), 15);
            }, delay);
          });
        }, 100);
        
        // Update score and XP/progress info in the evaluation section.
        document.getElementById('totalPoints').innerHTML = '<strong>' + data.total_points + '</strong>';
        document.getElementById('xpGained').innerHTML = '<strong>' + data.xp_gained + '</strong>';
        document.getElementById('currentLevel').innerHTML = '<strong>' + data.current_level + '</strong>';
        document.getElementById('xpProgressText').textContent = data.level_info.xp_into_level + ' / ' + data.level_info.xp_needed;
        document.getElementById('nextLevel').textContent = data.level_info.next_level;
        
        const xpOldBar = document.getElementById('xpOldBar');
        const xpNewBar = document.getElementById('xpNewBar');

        // If a level up occurred, show only the new level's progress
        if (data.leveled_up) {
          xpOldBar.style.display = 'none';
          xpNewBar.style.left = '0%';
          xpNewBar.style.width = data.level_info.progress_percent + '%';
        } else {
          xpOldBar.style.display = 'block';
          // Compute the old progress percentage.
          const oldXpValue = data.current_xp - data.xp_gained;
          const oldPercent = ((oldXpValue - data.level_info.current_threshold) / data.level_info.xp_needed) * 100;
          xpOldBar.style.width = oldPercent + '%';
          // The new portion is the difference between the new progress and the old percentage.
          xpNewBar.style.left = oldPercent + '%';
          const newPortion = data.level_info.progress_percent - oldPercent;
          xpNewBar.style.width = newPortion + '%';
        }

        if (data.leveled_up) {
          document.getElementById('levelUpMessage').textContent = "Level Up!";
        } else {
          document.getElementById('levelUpMessage').textContent = "";
        }
        
        var evaluationResults = document.getElementById('evaluationResults');
        evaluationResults.classList.remove('hidden');
        evaluationResults.classList.add('fade-in');
        evaluationResults.scrollIntoView({ behavior: 'smooth' });
      } catch (error) {
        console.error('Error submitting answer:', error);
      }
    });

    document.getElementById('nextQuestion').addEventListener('click', getNewQuestion);
    document.getElementById('rerollButton').addEventListener('click', getNewQuestion);

    // Categories Modal behavior
    const settingsButton = document.getElementById('settingsButton');
    const modalOverlay = document.getElementById('modalOverlay');
    settingsButton.addEventListener('click', (e) => {
      e.stopPropagation();
      modalOverlay.classList.remove('hidden');
      document.getElementById('categoriesError').classList.add('hidden');
    });

    // Category item toggle for selection
    document.querySelectorAll('.category-item').forEach(item => {
      item.addEventListener('click', function(e) {
        this.classList.toggle('selected');
      });
    });

    // Prevent modal overlay from closing if no category is selected
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        if (document.querySelectorAll('.category-item.selected').length === 0) {
          document.getElementById('categoriesError').classList.remove('hidden');
        } else {
          modalOverlay.classList.add('hidden');
          updateSelectedCategories();
        }
      }
    });

    // Close modal on "Done" click
    document.getElementById('closeCategories').addEventListener('click', (e) => {
      e.stopPropagation();
      if (document.querySelectorAll('.category-item.selected').length === 0) {
        document.getElementById('categoriesError').classList.remove('hidden');
        return;
      }
      modalOverlay.classList.add('hidden');
      updateSelectedCategories();
    });

    // Update selectedCategories based on the items with the "selected" class,
    // and re-roll the question if its category is no longer selected.
    function updateSelectedCategories() {
      selectedCategories = Array.from(document.querySelectorAll('.category-item.selected')).map(el => el.getAttribute('data-value'));
      // If the currently displayed question's category is not among the selected categories, re-roll.
      if (currentQuestion && !selectedCategories.includes(currentQuestion.category)) {
        getNewQuestion();
      }
    }

    // Load the first question when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      // Initialize selectedCategories based on default selected items.
      updateSelectedCategories();
      getNewQuestion();
    });

    document.getElementById('selectQuestionButton').addEventListener('click', () => {
      fetch('/get_all_questions')
        .then(response => response.json())
        .then(questions => {
          const questionList = document.getElementById('questionList');
          questionList.innerHTML = '';

          // Filter questions based on the currently selected categories.
          const filteredQuestions = questions.filter(q => selectedCategories.includes(q.category));

          // Group questions by category and record category order based on first appearance.
          const groups = {};
          const categoryOrder = [];
          filteredQuestions.forEach(question => {
            if (!groups[question.category]) {
              groups[question.category] = [];
              categoryOrder.push(question.category);
            }
            groups[question.category].push(question);
          });

          // If no questions are available for the selected categories, display a message.
          if (filteredQuestions.length === 0) {
            const noQuestionsItem = document.createElement('div');
            noQuestionsItem.className = 'text-gray-600 py-2';
            noQuestionsItem.textContent = 'No questions available for the selected categories.';
            questionList.appendChild(noQuestionsItem);
          } else {
            // Display questions in the order as they appear in the YAML file.
            categoryOrder.forEach(category => {
              const heading = document.createElement('h4');
              heading.className = 'mt-4 mb-2 font-bold text-lg';
              heading.textContent = category;
              questionList.appendChild(heading);

              groups[category].forEach(question => {
                const item = document.createElement('div');
                item.className = 'question-item cursor-pointer p-2 border-b hover:bg-gray-100';
                item.textContent = question.description;
                item.dataset.id = question.id;
                item.addEventListener('click', () => {
                  fetch('/select_question', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question_id: question.id })
                  })
                  .then(response => response.json())
                  .then(selected => {
                    // Update the current question on the UI.
                    currentQuestion = selected;
                    const categoryText = categoryIcons[selected.category]
                      ? categoryIcons[selected.category] + " " + selected.category
                      : selected.category;
                    document.getElementById('categoryBadge').textContent = categoryText;
                    document.getElementById('questionDescription').textContent = selected.description;
                    document.getElementById('answerInput').value = '';
                    document.getElementById('charCount').textContent = '200';
                    document.getElementById('evaluationResults').classList.add('hidden');
                    document.getElementById('errorMessage').textContent = '';
                    // Close the modal.
                    document.getElementById('questionSelectionOverlay').classList.add('hidden');
                  })
                  .catch(error => console.error('Error selecting question:', error));
                });
                questionList.appendChild(item);
              });
            });
          }
          document.getElementById('questionSelectionOverlay').classList.remove('hidden');
        })
        .catch(error => console.error('Error fetching questions:', error));
    });

    document.getElementById('closeQuestionSelection').addEventListener('click', () => {
      document.getElementById('questionSelectionOverlay').classList.add('hidden');
    });
  </script>
</body>
</html>