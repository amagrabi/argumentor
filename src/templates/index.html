<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArguMentor - Sharpen Your Reasoning</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
  <style>
    /* When selected, the category items now use gray-800 (a tiny bit darker) */
    .category-item.selected {
      background-color: #1F2937; /* Tailwind gray-800 */
      color: #fff;
      border-color: #1F2937;
    }
    .category-item {
      background-color: #fff;
      color: #000;
    }
    /* Animate the progress bar fill */
    .progress-fill {
      transition: width 1s ease-out, background-color 1s ease-out;
    }
    /* Fade-in effect for evaluation results */
    .fade-in {
      animation: fadeInAnimation 0.5s ease-in-out;
    }
    @keyframes fadeInAnimation {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div class="max-w-5xl mx-auto px-4 py-6">
    <!-- Header -->
    <header class="flex justify-between items-center mb-4">
      <div class="flex items-center space-x-3">
        <!-- Brain-inspired logo -->
        <!-- <img width="35" height="35" src="https://img.icons8.com/ios/50/brain--v1.png" alt="brain--v1"/> -->
        <!-- <img width="40" height="40" src="https://img.icons8.com/external-justicon-lineal-justicon/64/external-brain-human-organs-justicon-lineal-justicon.png" alt="external-brain-human-organs-justicon-lineal-justicon"/> -->
        <img width="40" height="40" src="https://img.icons8.com/external-outline-berkahicon/64/external-Brain-health-app-outline-berkahicon.png" alt="external-Brain-health-app-outline-berkahicon"/>
        <h1 class="text-2xl font-bold">ArguMentor</h1>
      </div>
      <div class="flex items-center space-x-2 text-sm">
        <div class="bg-gray-100 rounded-full px-3 py-1 flex items-center">
          <span>Score: <strong id="totalPoints">0</strong></span>
        </div>
        <button id="settingsButton" class="bg-gray-100 hover:bg-gray-200 text-gray-700 p-2 rounded-full flex items-center justify-center">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
          </svg>
        </button>
      </div>
    </header>

    <!-- Category Selection Modal Overlay -->
    <div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
      <div id="settingsPanel" class="bg-white border border-gray-200 rounded-xl shadow-lg p-4 w-11/12 max-w-md">
        <h3 class="text-lg font-bold mb-2">Settings</h3>
        <hr class="border-t border-gray-200 my-2" />
        <div class="mb-4">
          <h4 class="font-bold text-md mb-3">Filter Categories</h4>
          <div class="flex gap-2 flex-wrap">
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Philosophy">Philosophy</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Ethics">Ethics</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Business & Risk">Business & Risk</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Thought Experiments">Thought Experiments</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Politics">Politics</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Biases & Fallacies">Biases & Fallacies</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="Fun & Casual">Fun & Casual</div>
            <div class="category-item selected cursor-pointer rounded-full border border-gray-200 px-2 py-1 text-center text-xs inline-flex items-center justify-center whitespace-nowrap" data-value="AI & Future">AI & Future</div>
          </div>
        </div>
        <div id="categoriesError" class="text-red-500 mt-2 text-xs hidden">At least one category must be selected.</div>
        <div class="mt-4 text-right">
          <button id="closeCategories" class="bg-blue-500 text-white px-3 py-1 rounded-full text-sm">Done</button>
        </div>
      </div>
    </div>

    <!-- Slogan -->
    <p class="text-gray-600 text-center mb-8">
      Sharpen your reasoning skills. Tackle new questions, craft arguments, improve with AI-powered feedback.
    </p>

    <!-- Main Content -->
    <main class="bg-white rounded-3xl shadow-sm p-8 mb-8">
      <!-- Question Section -->
      <!-- Category badge above the question -->
      <div class="mb-2">
        <span id="categoryBadge" class="bg-gray-800 text-white px-4 py-2 rounded-full text-sm"></span>
      </div>
      <div class="flex items-start">
        <h2 id="questionDescription" class="text-3xl font-bold flex-1"></h2>
        <div class="flex flex-col ml-6 items-end">
          <!-- Reroll Button -->
          <button id="rerollButton" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 text-sm rounded-full font-medium flex items-center space-x-1">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Reroll</span>
          </button>
          <!-- Select Question Button placed below the Reroll button -->
          <button id="selectQuestionButton" class="mt-2 bg-gray-100 hover:bg-gray-200 text-gray-700 px-3 py-1 text-sm rounded-full font-medium flex items-center space-x-1">
            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path d="M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <span>Select Question</span>
          </button>
        </div>
      </div>
      
      <!-- Answer Section -->
      <div class="space-y-6">
        <div class="mt-8">
          <label class="block text-lg font-bold mb-2">Your Answer</label>
          <textarea 
            id="answerInput"
            class="w-full p-4 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:ring-0 h-32"
            placeholder="Type your answer here..."
            maxlength="200"
          ></textarea>
          <div class="mt-2">
            <div class="flex justify-between text-sm text-gray-500">
              <span>Characters remaining: <span id="charCount">200</span></span>
              <button id="submitAnswer" class="bg-blue-500 text-white px-6 py-2 rounded-full hover:bg-blue-600 transition-colors">
                Submit Answer
              </button>
            </div>
            <div id="errorMessage" class="text-sm text-red-500 mt-1"></div>
          </div>
        </div>
      </div>
    </main>
    
    <!-- Evaluation Results -->
    <div id="evaluationResults" class="hidden bg-white rounded-3xl shadow-sm p-8">
      <h2 class="text-2xl font-bold mb-6">Evaluation</h2>
      <div id="scores" class="grid gap-4 mb-8">
        <!-- Scores and feedback for each category will be populated here -->
      </div>
      <div class="mt-6 text-center">
        <button id="nextQuestion" class="bg-blue-500 text-white px-6 py-2 rounded-full hover:bg-blue-600 transition-colors">
          Next Question
        </button>
      </div>
    </div>
  </div>
  
  <div id="questionSelectionOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white border border-gray-200 rounded-xl shadow-lg p-4 w-11/12 max-w-2xl">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-bold">Select a Question</h3>
        <button id="closeQuestionSelection" class="bg-red-500 text-white px-3 py-1 rounded-full text-sm">X</button>
      </div>
      <div id="questionList" class="max-h-96 overflow-y-auto">
        <!-- List of questions will be dynamically populated here -->
      </div>
    </div>
  </div>
  
  <script>
    // Category icons mapping with updated icons
    const categoryIcons = {
      "Philosophy": "ðŸ“š",
      "Ethics": "âš–ï¸",
      "Business & Risk": "ðŸ’¼",
      "Thought Experiments": "ðŸ’¡",
      "Politics": "ðŸ›ï¸",
      "Biases & Fallacies": "ðŸ”",
      "AI & Future": "ðŸ¤–",
      "Fun & Casual": "ðŸ»"
    };

    // Global variable that stores your selected category values.
    var selectedCategories = [];
    // Global variable to store the currently displayed question.
    var currentQuestion = null;

    // Utility functions for color interpolation
    function hexToRgb(hex) {
      hex = hex.replace('#', '');
      let bigint = parseInt(hex, 16);
      let r = (bigint >> 16) & 255;
      let g = (bigint >> 8) & 255;
      let b = bigint & 255;
      return { r, g, b };
    }

    function rgbToHex(r, g, b) {
      return "#" + [r, g, b].map(x => {
        const hex = x.toString(16);
        return hex.length === 1 ? "0" + hex : hex;
      }).join('');
    }

    function interpolateColor(color1, color2, factor) {
      const r = Math.round(color1.r + factor * (color2.r - color1.r));
      const g = Math.round(color1.g + factor * (color2.g - color1.g));
      const b = Math.round(color1.b + factor * (color2.b - color1.b));
      return { r, g, b };
    }

    // Function to determine color based on score using linear interpolation
    // Gradient from red (#e53e3e) for a low score to green (#38a169) for a high score.
    function scoreToColor(score) {
        const minScore = 1, maxScore = 10;
        const clampedScore = Math.min(maxScore, Math.max(minScore, score));
        const factor = (clampedScore - minScore) / (maxScore - minScore);
        
        // Four-color gradient: red -> yellow -> lime -> green
        const colors = [
            hexToRgb("#ef4444"),  // Bright red (Tailwind red-500)
            hexToRgb("#eab308"),  // Warm yellow (Tailwind yellow-500)
            hexToRgb("#84cc16"),  // Vibrant lime (Tailwind lime-500)
            hexToRgb("#22c55e")   // Fresh green (Tailwind green-500)
        ];
        
        // Split into 3 equal segments
        if (factor < 0.33) {
            return interpolate(colors[0], colors[1], factor / 0.33);
        } else if (factor < 0.66) {
            return interpolate(colors[1], colors[2], (factor - 0.33) / 0.33);
        } else {
            return interpolate(colors[2], colors[3], (factor - 0.66) / 0.34);
        }
        
        function interpolate(start, end, ratio) {
            const result = {
                r: Math.round(start.r + (end.r - start.r) * ratio),
                g: Math.round(start.g + (end.g - start.g) * ratio),
                b: Math.round(start.b + (end.b - start.b) * ratio)
            };
            return rgbToHex(result.r, result.g, result.b);
        }
    }

    function getNewQuestion() {
      // Use URLSearchParams for proper encoding of query parameters
      let params = new URLSearchParams();
      if (selectedCategories.length) {
        params.set("categories", selectedCategories.join(","));
      }
      fetch("/get_question?" + params.toString())
        .then(response => response.json())
        .then(question => {
          currentQuestion = question; // Save the current question globally
          const categoryText = categoryIcons[question.category] ? categoryIcons[question.category] + " " + question.category : question.category;
          document.getElementById('categoryBadge').textContent = categoryText;
          document.getElementById('questionDescription').textContent = question.description;
          // Reset UI elements if needed...
          document.getElementById('answerInput').value = '';
          document.getElementById('charCount').textContent = '200';
          document.getElementById('evaluationResults').classList.add('hidden');
          document.getElementById('errorMessage').textContent = '';
        })
        .catch(error => {
          console.error('Error fetching question:', error);
        });
    }

    // Character counter and clear error messages on input
    const answerInput = document.getElementById('answerInput');
    const charCount = document.getElementById('charCount');
    answerInput.addEventListener('input', () => {
      const remaining = 200 - answerInput.value.length;
      charCount.textContent = remaining;
      document.getElementById('errorMessage').textContent = '';
    });

    // Helper function for number animation
    function animateNumber(element, start, end, interval) {
      let current = start;
      const steps = 20;
      const stepValue = (end - start) / steps;
      const startColor = hexToRgb("#e53e3e");
      const endColor = hexToRgb(element.getAttribute('data-color'));
      
      const timer = setInterval(() => {
        current += stepValue;
        const factor = (current - start) / (end - start);
        const color = interpolateColor(startColor, endColor, factor);
        element.style.color = rgbToHex(color.r, color.g, color.b);
        
        if ((stepValue > 0 && current >= end) || (stepValue < 0 && current <= end)) {
          current = end;
          clearInterval(timer);
        }
        element.textContent = Math.floor(current) + '/10';
      }, interval);
    }

    // Helper function for typewriter effect
    function typeWriter(element, text, speed) {
      element.textContent = ''; // clear existing text
      let i = 0;
      const timer = setInterval(() => {
        element.textContent += text.charAt(i);
        i++;
        if (i >= text.length) {
          clearInterval(timer);
        }
      }, speed);
    }

    // Submit answer and display evaluation with scores and feedback
    document.getElementById('submitAnswer').addEventListener('click', async () => {
      const answer = answerInput.value.trim();
      if (!answer) {
        document.getElementById('errorMessage').textContent = "Please provide an answer before submitting.";
        return;
      }
      try {
        const response = await fetch('/submit_answer', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ answer })
        });
        
        const data = await response.json();
        
        const scoresDiv = document.getElementById('scores');
        scoresDiv.innerHTML = '';
        Object.entries(data.evaluation.scores).forEach(([category, score]) => {
          const finalScore = score;             // e.g. 6, 7, 8 or 9
          const finalWidthPercent = score * 10;   // e.g. 60%, 70%, etc.
          const color = scoreToColor(score);
          const feedbackText = data.evaluation.feedback[category] || '';
          scoresDiv.innerHTML += `
            <div class="mb-4">
              <div class="flex justify-between items-center">
                <span class="font-medium">${category}</span>
                <span class="font-medium score-value" data-final="${finalScore}" data-color="${color}" style="color: #e53e3e;">1/10</span>
              </div>
              <div class="w-full bg-gray-200 rounded-full h-2 mt-1">
                <div class="rounded-full h-2 progress-fill" 
                      data-score="${finalWidthPercent}" 
                      data-color="${color}"
                      style="width: 10%; background-color: #e53e3e;"></div>
              </div>
              <p class="text-sm text-gray-500 feedback" data-final="${feedbackText}"></p>
            </div>
          `;
        });
        
        // A short delay so the DOM has updated, then animate with staggered delays.
        setTimeout(() => {
          document.querySelectorAll('.progress-fill').forEach((fill, index) => {
            const delay = index * 200;
            setTimeout(() => {
              const targetWidth = fill.getAttribute('data-score');
              const targetColor = fill.getAttribute('data-color'); // Get color from data attribute
              fill.style.backgroundColor = '#e53e3e';
              fill.style.width = '10%';
              void fill.offsetWidth; // Force repaint
              fill.style.width = targetWidth + '%';
              fill.style.backgroundColor = targetColor;
            }, delay);
          });
          // Animate the numeric rating from 1 up to its final value with staggered delay.
          document.querySelectorAll('.score-value').forEach((span, index) => {
            const delay = index * 200;
            setTimeout(() => {
              animateNumber(span, 1, parseInt(span.getAttribute('data-final')), 50);
            }, delay);
          });
          // Animate the feedback explanations with a typewriter effect with staggered delay.
          document.querySelectorAll('.feedback').forEach((paragraph, index) => {
            const delay = index * 200;
            setTimeout(() => {
              typeWriter(paragraph, paragraph.getAttribute('data-final'), 30);
            }, delay);
          });
        }, 100);
        
        document.getElementById('totalPoints').textContent = data.total_points;
        var evaluationResults = document.getElementById('evaluationResults');
        evaluationResults.classList.remove('hidden');
        evaluationResults.classList.add('fade-in');
      } catch (error) {
        console.error('Error submitting answer:', error);
      }
    });

    // Next question button
    document.getElementById('nextQuestion').addEventListener('click', getNewQuestion);
    // Reroll button to fetch new question
    document.getElementById('rerollButton').addEventListener('click', getNewQuestion);

    // Categories Modal behavior
    const settingsButton = document.getElementById('settingsButton');
    const modalOverlay = document.getElementById('modalOverlay');
    settingsButton.addEventListener('click', (e) => {
      e.stopPropagation();
      modalOverlay.classList.remove('hidden');
      document.getElementById('categoriesError').classList.add('hidden');
    });

    // Category item toggle for selection
    document.querySelectorAll('.category-item').forEach(item => {
      item.addEventListener('click', function(e) {
        this.classList.toggle('selected');
      });
    });

    // Prevent modal overlay from closing if no category is selected
    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        if (document.querySelectorAll('.category-item.selected').length === 0) {
          document.getElementById('categoriesError').classList.remove('hidden');
        } else {
          modalOverlay.classList.add('hidden');
          updateSelectedCategories();
        }
      }
    });

    // Close modal on "Done" click
    document.getElementById('closeCategories').addEventListener('click', (e) => {
      e.stopPropagation();
      if (document.querySelectorAll('.category-item.selected').length === 0) {
        document.getElementById('categoriesError').classList.remove('hidden');
        return;
      }
      modalOverlay.classList.add('hidden');
      updateSelectedCategories();
    });

    // Update selectedCategories based on the items with the "selected" class,
    // and re-roll the question if its category is no longer selected.
    function updateSelectedCategories() {
      selectedCategories = Array.from(document.querySelectorAll('.category-item.selected')).map(el => el.getAttribute('data-value'));
      // If the currently displayed question's category is not among the selected categories, re-roll.
      if (currentQuestion && !selectedCategories.includes(currentQuestion.category)) {
        getNewQuestion();
      }
    }

    // Load the first question when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      // Initialize selectedCategories based on default selected items.
      updateSelectedCategories();
      getNewQuestion();
    });

    document.getElementById('selectQuestionButton').addEventListener('click', () => {
      fetch('/get_all_questions')
        .then(response => response.json())
        .then(questions => {
          const questionList = document.getElementById('questionList');
          questionList.innerHTML = '';

          // Filter questions based on the currently selected categories.
          const filteredQuestions = questions.filter(q => selectedCategories.includes(q.category));

          // Group questions by category and record category order based on first appearance.
          const groups = {};
          const categoryOrder = [];
          filteredQuestions.forEach(question => {
            if (!groups[question.category]) {
              groups[question.category] = [];
              categoryOrder.push(question.category);
            }
            groups[question.category].push(question);
          });

          // If no questions are available for the selected categories, display a message.
          if (filteredQuestions.length === 0) {
            const noQuestionsItem = document.createElement('div');
            noQuestionsItem.className = 'text-gray-600 py-2';
            noQuestionsItem.textContent = 'No questions available for the selected categories.';
            questionList.appendChild(noQuestionsItem);
          } else {
            // Display questions in the order as they appear in the YAML file.
            categoryOrder.forEach(category => {
              const heading = document.createElement('h4');
              heading.className = 'mt-4 mb-2 font-bold text-lg';
              heading.textContent = category;
              questionList.appendChild(heading);

              groups[category].forEach(question => {
                const item = document.createElement('div');
                item.className = 'question-item cursor-pointer p-2 border-b hover:bg-gray-100';
                item.textContent = question.description;
                item.dataset.id = question.id;
                item.addEventListener('click', () => {
                  fetch('/select_question', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question_id: question.id })
                  })
                  .then(response => response.json())
                  .then(selected => {
                    // Update the current question on the UI.
                    currentQuestion = selected;
                    const categoryText = categoryIcons[selected.category]
                      ? categoryIcons[selected.category] + " " + selected.category
                      : selected.category;
                    document.getElementById('categoryBadge').textContent = categoryText;
                    document.getElementById('questionDescription').textContent = selected.description;
                    document.getElementById('answerInput').value = '';
                    document.getElementById('charCount').textContent = '200';
                    document.getElementById('evaluationResults').classList.add('hidden');
                    document.getElementById('errorMessage').textContent = '';
                    // Close the modal.
                    document.getElementById('questionSelectionOverlay').classList.add('hidden');
                  })
                  .catch(error => console.error('Error selecting question:', error));
                });
                questionList.appendChild(item);
              });
            });
          }
          document.getElementById('questionSelectionOverlay').classList.remove('hidden');
        })
        .catch(error => console.error('Error fetching questions:', error));
    });

    document.getElementById('closeQuestionSelection').addEventListener('click', () => {
      document.getElementById('questionSelectionOverlay').classList.add('hidden');
    });
  </script>
</body>
</html>